<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>AR Keyholder - Enhanced WebAR</title>
    <!-- å®‰å®šç‰ˆã®CDNä½¿ç”¨ -->
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.js"></script>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>
    <script type="module" src="/src/main.ts"></script>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; 
            overflow: hidden; 
            background: #000;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        /* iOS Safariç‰¹åŒ–æœ€é©åŒ– */
        @supports (-webkit-appearance: none) {
            body {
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
        }
        
        #ar-scene { 
            width: 100vw; 
            height: 100vh; 
        }
        
        #status-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 8px;
            border-radius: 6px;
            z-index: 1000;
            backdrop-filter: blur(5px);
            font-size: 11px;
        }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
        }
        
        .status-item {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .status-ok { color: #4ade80; }
        .status-error { color: #f87171; }
        .status-warning { color: #fbbf24; }
        
        .progress-bar {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #4ade80;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px;
            border-radius: 6px;
            text-align: left;
            font-size: 11px;
            backdrop-filter: blur(5px);
            z-index: 1000;
        }
        
        #position-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 180px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 8px;
            text-align: center;
            font-size: 10px;
            display: none;
            z-index: 1001;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        #position-controls.hidden {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }
        
        #status-overlay.hidden {
            opacity: 0;
            transform: translateY(-20px);
            pointer-events: none;
        }
        
        #settings-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(52, 73, 94, 0.9);
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        #settings-btn:hover {
            background: rgba(52, 73, 94, 1);
            transform: rotate(90deg);
        }
        
        #settings-btn:active {
            transform: rotate(90deg) scale(0.95);
        }
        
        #settings-menu {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            min-width: 200px;
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        #settings-menu.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }
        
        .menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .menu-item:last-child {
            border-bottom: none;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #3498db;
        }
        
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        
        #cms-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(46, 204, 113, 0.9);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        #cms-btn:hover {
            background: rgba(46, 204, 113, 1);
            transform: translateY(-2px);
        }
        
        .position-btn {
            background: rgba(52, 152, 219, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 8px;
            margin: 1px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            min-width: 26px;
        }
        
        .position-btn:active {
            background: rgba(41, 128, 185, 1);
            transform: scale(0.95);
        }
        
        #center-crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            z-index: 500;
            pointer-events: none;
        }
        
        #center-crosshair::before,
        #center-crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        
        #center-crosshair::before {
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            transform: translateY(-50%);
        }
        
        #center-crosshair::after {
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <!-- è¨­å®šãƒœã‚¿ãƒ³ -->
    <button id="settings-btn" onclick="toggleSettings()">âš™ï¸</button>
    
    <!-- CMSãƒœã‚¿ãƒ³ -->
    <button id="cms-btn" onclick="openCMS()">ğŸ“Š CMS</button>
    
    <!-- è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼ -->
    <div id="settings-menu">
        <div class="menu-item">
            <span>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º</span>
            <label class="toggle-switch">
                <input type="checkbox" id="status-toggle" checked onchange="toggleStatus()">
                <span class="slider"></span>
            </label>
        </div>
        <div class="menu-item">
            <span>ä½ç½®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«</span>
            <label class="toggle-switch">
                <input type="checkbox" id="controls-toggle" checked onchange="toggleControls()">
                <span class="slider"></span>
            </label>
        </div>
        <div class="menu-item">
            <span>ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰</span>
            <label class="toggle-switch">
                <input type="checkbox" id="debug-toggle" onchange="toggleDebug()">
                <span class="slider"></span>
            </label>
        </div>
        <div class="menu-item" style="border: none; padding-top: 15px;">
            <button onclick="resetAll()" style="width: 100%; background: #e74c3c; color: white; border: none; padding: 8px; border-radius: 5px;">å…¨è¨­å®šãƒªã‚»ãƒƒãƒˆ</button>
        </div>
    </div>
    
    <!-- ä¸­å¤®åå­—ç·š -->
    <div id="center-crosshair"></div>
    
    <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ -->
    <div id="loading-screen">
        <h2>ğŸ¯ AR Keyholder</h2>
        <p>ä½ç½®ä¿®æ­£ç‰ˆ</p>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
        <div id="loading-status">åˆæœŸåŒ–ä¸­...</div>
    </div>
    
    <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º -->
    <div id="status-overlay" style="display: none;">
        <h3>ğŸ¯ AR Keyholder</h3>
        <div class="status-item" id="camera-status">ğŸ“· ã‚«ãƒ¡ãƒ©: åˆæœŸåŒ–ä¸­</div>
        <div class="status-item" id="ar-status">ğŸ” AR: å¾…æ©Ÿä¸­</div>
        <div class="status-item" id="marker-status">ğŸ“ ãƒãƒ¼ã‚«ãƒ¼: æœªæ¤œå‡º</div>
        <div class="status-item" id="position-status">ğŸ“ ä½ç½®: èª¿æ•´ä¸­</div>
        <div class="status-item" id="masking-status">ğŸ­ ãƒã‚¹ã‚­ãƒ³ã‚°: æœ€é©åŒ–æ¸ˆã¿</div>
        <div class="status-item" id="ios-status">ğŸ“± iOS: æ¤œå‡ºä¸­</div>
    </div>
    
    <!-- ä½ç½®èª¿æ•´ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
    <div id="position-controls">
        <div><strong>ä½ç½®å¾®èª¿æ•´:</strong></div>
        <div style="margin: 5px 0;">
            <button class="position-btn" onclick="adjustPosition('left')">â†</button>
            <button class="position-btn" onclick="adjustPosition('up')">â†‘</button>
            <button class="position-btn" onclick="adjustPosition('down')">â†“</button>
            <button class="position-btn" onclick="adjustPosition('right')">â†’</button>
        </div>
        <div style="margin: 3px 0;">
            <button class="position-btn" onclick="adjustPosition('forward')">Z+</button>
            <button class="position-btn" onclick="adjustPosition('backward')">Z-</button>
            <button class="position-btn" onclick="resetPosition()" style="background: rgba(231, 76, 60, 0.8);">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        <div style="margin: 3px 0;">
            <button class="position-btn" onclick="ensureObjectVisibility()" style="background: rgba(46, 204, 113, 0.8); font-size: 9px;">è¡¨ç¤º</button>
        </div>
        <div style="margin: 3px 0; font-size: 9px;">
            <button class="position-btn" onclick="centerOnMarker()" style="font-size: 9px; padding: 4px 6px; background: rgba(39, 174, 96, 0.8);">ä¸­å¤®é…ç½®</button>
            <button class="position-btn" onclick="setPresetPosition('elevated')" style="font-size: 9px; padding: 4px 6px;">ä¸Š</button>
        </div>
        <div id="debug-info" style="font-size: 8px; color: #bdc3c7; margin-top: 2px;">Pos: (0.000, 0.000, 0.000)</div>
    </div>
    
    <!-- ä½¿ç”¨æ–¹æ³• -->
    <div id="instructions">
        <strong>ğŸ“– ä½¿ã„æ–¹:</strong><br>
        1. ãƒãƒ¼ã‚«ãƒ¼ã‚’ä¸­å¤®ã«<br>
        2. å³ä¸‹ãƒœã‚¿ãƒ³ã§èª¿æ•´<br>
        3. ãƒªã‚»ãƒƒãƒˆã§åˆæœŸåŒ–
    </div>

    <!-- WebGPU Canvas (overlay) -->
    <canvas id="webgpu-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none;"></canvas>
    
    <!-- AR.js Scene - ä½ç½®ç²¾å¯†èª¿æ•´ -->
    <a-scene
        id="ar-scene"
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true; colorManagement: true; antialias: true; alpha: true;"
        embedded
        arjs="
            trackingMethod: best; 
            sourceType: webcam; 
            debugUIEnabled: false; 
            detectionMode: mono_and_matrix; 
            matrixCodeType: 3x3;
        "
        loading-screen="enabled: false">
        
        <!-- Hiroãƒãƒ¼ã‚«ãƒ¼ - ãƒã‚¹ã‚­ãƒ³ã‚°æœ€é©åŒ– -->
        <a-marker 
            preset="hiro" 
            id="hiro-marker">
            
            <!-- 3Dã‚­ãƒ¼ãƒ›ãƒ«ãƒ€ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ - è¡¨ç¤ºç¢ºå®ŸåŒ– -->
            <a-entity id="keyholder-object" position="0 0 0" visible="true">
                
                <!-- ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£ï¼ˆèµ¤ã„ç®±ï¼‰ - ãƒãƒ¼ã‚«ãƒ¼ä¸­å¤®ã«é…ç½® -->
                <a-box
                    id="main-body"
                    position="0 0.3 0"
                    width="0.4"
                    height="0.6"
                    depth="0.15"
                    color="#e74c3c"
                    visible="true"
                    animation="property: rotation; to: 0 360 0; loop: true; dur: 10000">
                </a-box>
                
                <!-- é¡”ï¼ˆé»„è‰²ã„çƒï¼‰ -->
                <a-sphere
                    id="head"
                    position="0 0.7 0.1"
                    radius="0.12"
                    color="#f1c40f"
                    visible="true">
                </a-sphere>
                
                <!-- ç›®ï¼ˆå·¦ï¼‰ -->
                <a-sphere
                    position="-0.04 0.75 0.18"
                    radius="0.02"
                    color="#000"
                    visible="true">
                </a-sphere>
                
                <!-- ç›®ï¼ˆå³ï¼‰ -->
                <a-sphere
                    position="0.04 0.75 0.18"
                    radius="0.02"
                    color="#000"
                    visible="true">
                </a-sphere>
                
                <!-- ã‚­ãƒ¼ãƒªãƒ³ã‚°ï¼ˆã‚·ãƒ«ãƒãƒ¼ï¼‰ -->
                <a-torus
                    id="ring"
                    position="0 1.0 0"
                    color="#bdc3c7"
                    radius="0.15"
                    radius-tubular="0.015"
                    rotation="90 0 0"
                    visible="true"
                    animation="property: rotation; to: 90 360 0; loop: true; dur: 8000">
                </a-torus>
                
                <!-- ãƒ™ãƒ¼ã‚¹ï¼ˆå½±ç”¨ãƒ»ãƒã‚¹ã‚­ãƒ³ã‚°å¯¾å¿œï¼‰ -->
                <a-cylinder
                    position="0 0.01 0"
                    radius="0.25"
                    height="0.01"
                    color="#34495e"
                    material="opacity: 0.3; transparent: true; depthWrite: false;"
                    visible="true">
                </a-cylinder>
            </a-entity>
        </a-marker>
        
        <!-- ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚° -->
        <a-light type="ambient" color="#ffffff" intensity="0.7"></a-light>
        <a-light type="directional" position="0 1 0.5" color="#ffffff" intensity="0.5"></a-light>
        
        <!-- ã‚«ãƒ¡ãƒ© -->
        <a-entity camera></a-entity>
    </a-scene>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let arScene, marker, keyholderObject;
        let currentPosition = { x: 0, y: 0, z: 0 }; // ä¸­å¤®åŸºæº–ã®ç²¾å¯†ä½ç½®
        let initializationComplete = false;
        let webARApp = null; // TypeScript WebAR app instance
        let useWebGPU = false; // WebGPU availability flag
        
        // DOMè¦ç´ 
        const loadingScreen = document.getElementById('loading-screen');
        const statusOverlay = document.getElementById('status-overlay');
        const instructions = document.getElementById('instructions');
        const positionControls = document.getElementById('position-controls');
        const progress = document.getElementById('progress');
        const loadingStatus = document.getElementById('loading-status');
        
        const cameraStatus = document.getElementById('camera-status');
        const arStatus = document.getElementById('ar-status');
        const markerStatus = document.getElementById('marker-status');
        const positionStatus = document.getElementById('position-status');
        
        // ä½ç½®èª¿æ•´é–¢æ•°
        function adjustPosition(direction) {
            const step = 0.05; // èª¿æ•´å¹…ã‚’ç´°ã‹ã
            
            switch(direction) {
                case 'left':
                    currentPosition.x -= step;
                    break;
                case 'right':
                    currentPosition.x += step;
                    break;
                case 'up':
                    currentPosition.y += step;
                    break;
                case 'down':
                    currentPosition.y -= step;
                    break;
                case 'forward':
                    currentPosition.z += step;
                    break;
                case 'backward':
                    currentPosition.z -= step;
                    break;
            }
            
            updateObjectPosition();
        }
        
        function resetPosition() {
            currentPosition = { x: 0, y: 0, z: 0 }; // å®Œå…¨ãªä¸­å¤®
            updateObjectPosition();
            console.log('ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
        }
        
        // ãƒãƒ¼ã‚«ãƒ¼ä¸­å¤®ã«å¼·åˆ¶é…ç½®
        function centerOnMarker() {
            currentPosition = { x: 0, y: 0, z: 0 };
            const keyholderObject = document.getElementById('keyholder-object');
            if (keyholderObject) {
                keyholderObject.setAttribute('position', '0 0 0');
                console.log('ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒãƒ¼ã‚«ãƒ¼ä¸­å¤®ã«é…ç½®');
            }
        }
        
        // ç²¾å¯†èª¿æ•´æ©Ÿèƒ½
        function fineAdjustPosition(axis, delta) {
            currentPosition[axis] += delta;
            updateObjectPosition();
        }
        
        // ãƒ—ãƒªã‚»ãƒƒãƒˆä½ç½®
        function setPresetPosition(preset) {
            switch(preset) {
                case 'center':
                    currentPosition = { x: 0, y: 0, z: 0 };
                    break;
                case 'elevated':
                    currentPosition = { x: 0, y: 0.1, z: 0 };
                    break;
                case 'forward':
                    currentPosition = { x: 0, y: 0, z: 0.1 };
                    break;
            }
            updateObjectPosition();
        }
        
        function updateObjectPosition() {
            if (keyholderObject) {
                const posStr = `${currentPosition.x} ${currentPosition.y} ${currentPosition.z}`;
                keyholderObject.setAttribute('position', posStr);
                console.log(`Position updated to: ${posStr}`);
                
                updateStatus(positionStatus, `X:${currentPosition.x.toFixed(2)} Y:${currentPosition.y.toFixed(2)} Z:${currentPosition.z.toFixed(2)}`, 'ok');
                
                // ãƒ‡ãƒãƒƒã‚°æƒ…å ±è¡¨ç¤º
                const debugInfo = document.getElementById('debug-info');
                if (debugInfo) {
                    debugInfo.textContent = `Pos: (${currentPosition.x.toFixed(3)}, ${currentPosition.y.toFixed(3)}, ${currentPosition.z.toFixed(3)})`;
                }
            }
        }
        
        // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹æ›´æ–°
        function updateProgress(percentage, message) {
            progress.style.width = percentage + '%';
            loadingStatus.textContent = message;
            console.log(`Progress ${percentage}%: ${message}`);
        }
        
        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
        function updateStatus(element, message, type = 'ok') {
            element.innerHTML = element.innerHTML.split(':')[0] + ': ' + 
                `<span class="status-${type}">${message}</span>`;
        }
        
        // iOS Safariæœ€é©åŒ–é–¢æ•°
        function optimizeForIOSSafari() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            
            if (isIOS && isSafari) {
                console.log('iOS Safariã§ã®æœ€é©åŒ–ã‚’é©ç”¨ä¸­...');
                
                // ã‚«ãƒ¡ãƒ©è§£åƒåº¦ã‚’iOSç”¨ã«èª¿æ•´
                if (arScene) {
                    arScene.setAttribute('arjs', `
                        trackingMethod: best;
                        sourceType: webcam;
                        debugUIEnabled: false;
                        detectionMode: mono_and_matrix;
                        matrixCodeType: 3x3;
                        sourceWidth: 960;
                        sourceHeight: 640;
                        displayWidth: 960;
                        displayHeight: 640;
                        maxDetectionRate: 25;
                        canvasWidth: 960;
                        canvasHeight: 640;
                        smoothCount: 15;
                        smoothTolerance: 0.005;
                        smoothThreshold: 8;
                    `);
                }
                
                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
                document.addEventListener('touchstart', function() {}, { passive: true });
                document.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });
                
                // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰ä¿ƒé€²
                if (document.documentElement.requestFullscreen) {
                    setTimeout(() => {
                        const fullscreenBtn = document.createElement('button');
                        fullscreenBtn.innerHTML = 'ğŸ“± ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³';
                        fullscreenBtn.style.cssText = 'position: fixed; top: 60px; right: 20px; z-index: 9999; background: rgba(52, 152, 219, 0.9); color: white; border: none; padding: 8px 12px; border-radius: 6px; font-size: 12px;';
                        fullscreenBtn.onclick = () => {
                            document.documentElement.requestFullscreen();
                            fullscreenBtn.remove();
                        };
                        document.body.appendChild(fullscreenBtn);
                    }, 3000);
                }
                
                return true;
            }
            return false;
        }
        
        // 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¤ºç¢ºå®ŸåŒ–é–¢æ•°
        function ensureObjectVisibility() {
            const keyholderObject = document.getElementById('keyholder-object');
            const mainBody = document.getElementById('main-body');
            const characterHead = document.getElementById('character-head');
            const keyRing = document.getElementById('key-ring');
            
            if (keyholderObject) {
                keyholderObject.setAttribute('visible', 'true');
                console.log('Keyholder object visibility ensured');
            }
            
            // å„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®è¡¨ç¤ºã‚’å¼·åˆ¶çš„ã«æœ‰åŠ¹åŒ–
            [mainBody, characterHead, keyRing].forEach(element => {
                if (element) {
                    element.setAttribute('visible', 'true');
                    // ã‚¨ãƒŸãƒƒã‚·ãƒ–å…‰ã‚’è¿½åŠ ã—ã¦è¦‹ãˆã‚„ã™ãã™ã‚‹ï¼ˆã‚¨ãƒ©ãƒ¼ä¿®æ­£ï¼‰
                    const currentMaterial = element.getAttribute('material') || '';
                    if (typeof currentMaterial === 'string' && !currentMaterial.includes('emissive')) {
                        element.setAttribute('material', currentMaterial + '; emissive: ' + element.getAttribute('color') + '; emissiveIntensity: 0.2;');
                    }
                }
            });
        }
        
        // ãƒã‚¹ã‚­ãƒ³ã‚°æœ€é©åŒ–é–¢æ•°
        function adjustRenderingOrder() {
            const keyholderObject = document.getElementById('keyholder-object');
            const basePlatform = document.getElementById('base-platform');
            
            if (keyholderObject) {
                keyholderObject.setAttribute('material', 'depthTest: true; depthWrite: true;');
            }
            
            if (basePlatform) {
                basePlatform.setAttribute('material', 'depthTest: false; depthWrite: false; renderOrder: 999;');
            }
        }
        
        // ARåˆæœŸåŒ–
        async function initializeAR() {
            console.log('Starting enhanced AR with iOS Safari optimization...');
            updateProgress(25, 'A-Frameã‚’åˆæœŸåŒ–ä¸­...');
            
            // iOS Safariæœ€é©åŒ–ã‚’å…ˆã«å®Ÿè¡Œ
            const isIOSOptimized = optimizeForIOSSafari();
            if (isIOSOptimized) {
                updateProgress(30, 'iOS Safariæœ€é©åŒ–é©ç”¨æ¸ˆã¿...');
                updateStatus(document.getElementById('ios-status'), 'Safariæœ€é©åŒ–æ¸ˆã¿', 'ok');
            } else {
                updateStatus(document.getElementById('ios-status'), 'æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶', 'ok');
            }
            
            // WebGPUå¯¾å¿œãƒã‚§ãƒƒã‚¯ï¼ˆiOSã§ã¯ç„¡åŠ¹åŒ–ï¼‰
            if (navigator.gpu && !isIOSOptimized) {
                try {
                    updateProgress(35, 'WebGPUåˆæœŸåŒ–ä¸­...');
                    // WebGPUåˆæœŸåŒ–ã¯ main.ts ã§å‡¦ç†
                    useWebGPU = true;
                    console.log('WebGPUæ”¯æ´ãŒåˆ©ç”¨å¯èƒ½ã§ã™');
                } catch (error) {
                    console.warn('WebGPUåˆæœŸåŒ–å¤±æ•—ã€WebGLãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯:', error);
                    useWebGPU = false;
                }
            } else if (isIOSOptimized) {
                console.log('iOS Safariã§ã¯WebGLã‚’ä½¿ç”¨ã—ã¾ã™');
                useWebGPU = false;
            }
            
            if (typeof AFRAME !== 'undefined') {
                setupARScene();
            } else {
                setTimeout(initializeAR, 100);
            }
        }
        
        function setupARScene() {
            updateProgress(50, 'ARã‚·ãƒ¼ãƒ³ã‚’è¨­å®šä¸­...');
            
            arScene = document.querySelector('a-scene');
            marker = document.querySelector('#hiro-marker');
            keyholderObject = document.querySelector('#keyholder-object');
            
            if (!arScene || !marker) {
                setTimeout(setupARScene, 100);
                return;
            }
            
            // AR.jsã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            arScene.addEventListener('arjs-video-loaded', () => {
                console.log('ğŸ‰ AR video loaded - position adjustment ready!');
                updateStatus(arStatus, 'ã‚«ãƒ¡ãƒ©æ˜ åƒå–å¾—æˆåŠŸ', 'ok');
                updateProgress(100, 'ARåˆæœŸåŒ–å®Œäº†ï¼');
                
                setTimeout(showARInterface, 500);
                initializationComplete = true;
            });
            
            // ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡ºã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒã‚¹ã‚­ãƒ³ã‚°æœ€é©åŒ–ï¼‰
            marker.addEventListener('markerFound', () => {
                console.log('ğŸ¯ Hiro marker detected - starting enhanced rendering!');
                updateStatus(markerStatus, 'æ¤œå‡ºä¸­ - é«˜ç²¾ç´°ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹!', 'ok');
                
                // ä½ç½®èª¿æ•´ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’è¡¨ç¤º
                positionControls.style.display = 'block';
                
                // ãƒãƒ¼ã‚«ãƒ¼å¢ƒç•Œã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¡¨ç¤º
                const boundary = document.getElementById('marker-boundary');
                if (boundary) {
                    boundary.setAttribute('visible', 'true');
                }
                
                // 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¡¨ç¤ºã‚’å¼·åˆ¶çš„ã«æœ‰åŠ¹åŒ–
                ensureObjectVisibility();
                
                // å…¨ã¦ã®å­è¦ç´ ã‚‚å¼·åˆ¶çš„ã«è¡¨ç¤º
                forceObjectVisibility();
                
                // ãƒãƒ¼ã‚«ãƒ¼ä¸­å¤®ã«é…ç½®
                centerOnMarker();
                
                // WebGPUãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’é€šçŸ¥
                if (useWebGPU && webARApp) {
                    const markerMatrix = marker.object3D.matrixWorld.elements;
                    webARApp.onMarkerFound(markerMatrix);
                }
                
                // ãƒã‚¹ã‚­ãƒ³ã‚°å“è³ªå‘ä¸Šã®ãŸã‚ã®Z-indexèª¿æ•´
                adjustRenderingOrder();
                
                // åˆæœŸä½ç½®ã‚’é©ç”¨
                updateObjectPosition();
            });
            
            marker.addEventListener('markerLost', () => {
                console.log('Hiro marker lost');
                updateStatus(markerStatus, 'æœªæ¤œå‡º', 'warning');
                updateStatus(positionStatus, 'èª¿æ•´ä¸­', 'warning');
                
                // ãƒãƒ¼ã‚«ãƒ¼å¢ƒç•Œã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’éè¡¨ç¤º
                const boundary = document.getElementById('marker-boundary');
                if (boundary) {
                    boundary.setAttribute('visible', 'false');
                }
                
                // WebGPUãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’åœæ­¢
                if (useWebGPU && webARApp) {
                    webARApp.onMarkerLost();
                }
                
                // ä½ç½®èª¿æ•´ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’éè¡¨ç¤º
                positionControls.style.display = 'none';
            });
            
            updateProgress(75, 'ã‚«ãƒ¡ãƒ©èµ·å‹•ä¸­...');
            
            // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
            setTimeout(() => {
                if (!initializationComplete) {
                    console.log('Forcing AR interface display...');
                    showARInterface();
                }
            }, 10000);
        }
        
        function showARInterface() {
            updateStatus(cameraStatus, 'ã‚¢ã‚¯ãƒ†ã‚£ãƒ–', 'ok');
            updateStatus(arStatus, 'æº–å‚™å®Œäº†', 'ok');
            
            loadingScreen.style.display = 'none';
            statusOverlay.style.display = 'block';
            instructions.style.display = 'block';
            
            // UIè‡ªå‹•éè¡¨ç¤ºã‚’ç„¡åŠ¹åŒ–ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¨­å®šã§åˆ¶å¾¡ï¼‰
            console.log('AR interface ready - UI controls active');
            
            console.log('ğŸš€ Enhanced AR interface ready!');
        }
        
        // iOS Safariç”¨ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹æœ€é©åŒ–
        function requestCameraPermission() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                return navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                }).then(stream => {
                    // ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åœæ­¢ï¼ˆAR.jsãŒå–ã‚Šç›´ã—ã¦ä½¿ç”¨ï¼‰
                    stream.getTracks().forEach(track => track.stop());
                    return true;
                }).catch(error => {
                    console.warn('ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ:', error);
                    return false;
                });
            }
            return Promise.resolve(false);
        }
        
        // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šèª­ã¿è¾¼ã¿
        function loadProjectSettings() {
            const urlParams = new URLSearchParams(window.location.search);
            const projectId = urlParams.get('project');
            
            if (projectId) {
                console.log('Loading project:', projectId);
                const projects = JSON.parse(localStorage.getItem('ar-projects') || '[]');
                const project = projects.find(p => p.id === projectId);
                
                if (project) {
                    console.log('Project found:', project);
                    applyProjectSettings(project);
                    return project;
                } else {
                    console.warn('Project not found:', projectId);
                }
            }
            
            console.log('Using default settings');
            return null;
        }
        
        // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šé©ç”¨
        function applyProjectSettings(project) {
            console.log('Applying project settings:', project);
            
            // ç¾åœ¨ã¯Hiroãƒãƒ¼ã‚«ãƒ¼ã®ã¿å¯¾å¿œï¼ˆã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ã‚«ãƒ¼ã¯ä»Šå¾Œå®Ÿè£…äºˆå®šï¼‰
            console.log('ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ã‚«ãƒ¼æ©Ÿèƒ½ã¯é–‹ç™ºä¸­ã§ã™ã€‚ç¾åœ¨ã¯Hiroãƒãƒ¼ã‚«ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚');
            
            // 3Dãƒ¢ãƒ‡ãƒ«è¨­å®š
            const keyholderObject = document.getElementById('keyholder-object');
            if (project.character?.modelUrl && project.character.modelUrl !== '' && project.character.modelUrl !== 'keyholder-default') {
                console.log('Loading custom 3D model:', project.character.modelUrl);
                loadCustomModel(project.character.modelUrl, project.character.scale || 0.5);
            } else {
                console.log('Using default keyholder model');
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ‡ãƒ«ãŒæ¶ˆãˆãªã„ã‚ˆã†ã«ã™ã‚‹
            }
            
            // ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨
            if (project.character?.scale) {
                const scale = project.character.scale;
                keyholderObject.setAttribute('scale', `${scale} ${scale} ${scale}`);
                console.log('Applied scale:', scale);
            }
            
            // ä½ç½®è¨­å®š
            if (project.character?.position) {
                const pos = project.character.position;
                keyholderObject.setAttribute('position', `${pos[0]} ${pos[1]} ${pos[2]}`);
                console.log('Applied position:', pos);
            }
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ 3Dãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
        function loadCustomModel(modelUrl, scale = 0.5) {
            const keyholderObject = document.getElementById('keyholder-object');
            
            if (modelUrl.includes('.glb') || modelUrl.includes('.gltf')) {
                // GLTFãƒ¢ãƒ‡ãƒ«ã®å ´åˆ
                keyholderObject.innerHTML = `
                    <a-gltf-model 
                        src="${modelUrl}" 
                        scale="${scale} ${scale} ${scale}"
                        position="0 0 0"
                        animation="property: rotation; to: 0 360 0; loop: true; dur: 10000"
                        visible="true">
                    </a-gltf-model>
                `;
                console.log('GLTF model loaded:', modelUrl);
            } else {
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚­ãƒ¼ãƒ›ãƒ«ãƒ€ãƒ¼ã®å ´åˆã¯å…ƒã®å†…å®¹ã‚’ä¿æŒ
                console.log('Using default keyholder model');
            }
        }
        
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¤ºå¼·åˆ¶åŒ–é–¢æ•°
        function forceObjectVisibility() {
            const keyholderObject = document.getElementById('keyholder-object');
            if (keyholderObject) {
                keyholderObject.setAttribute('visible', 'true');
                const allElements = keyholderObject.querySelectorAll('*');
                allElements.forEach(el => {
                    el.setAttribute('visible', 'true');
                });
                console.log('Forced all objects visible');
            }
        }
        
        // åˆæœŸåŒ–é–‹å§‹
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('ğŸ¯ AR Keyholder - iOS Safari Optimized Version');
            
            updateProgress(5, 'ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºä¸­...');
            
            // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šèª­ã¿è¾¼ã¿
            const currentProject = loadProjectSettings();
            
            // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¡¨ç¤ºã‚’å¼·åˆ¶
            setTimeout(() => {
                forceObjectVisibility();
            }, 2000);
            
            // iOS Safariã§ã®ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ç¢ºèª
            const cameraPermitted = await requestCameraPermission();
            if (!cameraPermitted) {
                updateStatus(cameraStatus, 'ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒå¿…è¦', 'error');
                setTimeout(() => {
                    alert('ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯ã—ã¦ãã ã•ã„ã€‚');
                }, 1000);
            }
            
            updateProgress(10, 'ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ä¸­...');
            updateStatus(cameraStatus, 'æº–å‚™ä¸­...', 'warning');
            
            setTimeout(initializeAR, 500);
        });
        
        // UIåˆ¶å¾¡é–¢æ•°ï¼ˆar-fixed.htmlã‹ã‚‰ç§»æ¤ï¼‰
        let settingsVisible = false;
        let statusVisible = true;
        let controlsVisible = true;
        let debugMode = false;
        
        function toggleSettings() {
            settingsVisible = !settingsVisible;
            document.getElementById('settings-menu').classList.toggle('visible', settingsVisible);
        }
        
        function toggleStatus() {
            statusVisible = !statusVisible;
            document.getElementById('status-overlay').classList.toggle('hidden', !statusVisible);
        }
        
        function toggleControls() {
            controlsVisible = !controlsVisible;
            document.getElementById('position-controls').classList.toggle('hidden', !controlsVisible);
        }
        
        function toggleDebug() {
            debugMode = !debugMode;
            console.log('Debug mode:', debugMode ? 'ON' : 'OFF');
        }
        
        function openCMS() {
            window.open('admin.html', '_blank');
        }
        
        function resetAll() {
            currentPosition = { x: 0, y: 0, z: 0 };
            updateObjectPosition();
            
            // UIçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            statusVisible = true;
            controlsVisible = true;
            debugMode = false;
            settingsVisible = false;
            
            document.getElementById('status-overlay').classList.remove('hidden');
            document.getElementById('position-controls').classList.remove('hidden');
            document.getElementById('settings-menu').classList.remove('visible');
            
            document.getElementById('status-toggle').checked = true;
            document.getElementById('controls-toggle').checked = true;
            document.getElementById('debug-toggle').checked = false;
            
            console.log('Complete reset');
        }
        
        // è¨­å®šãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#settings-menu') && !e.target.closest('#settings-btn')) {
                settingsVisible = false;
                document.getElementById('settings-menu').classList.remove('visible');
            }
        });
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½
        window.ARKeyholder = {
            version: '3.0.0-ios-safari-optimized',
            adjustLeft: () => adjustPosition('left'),
            adjustRight: () => adjustPosition('right'),
            adjustUp: () => adjustPosition('up'),
            adjustDown: () => adjustPosition('down'),
            adjustForward: () => adjustPosition('forward'),
            adjustBackward: () => adjustPosition('backward'),
            fineLeft: () => fineAdjustPosition('x', -0.01),
            fineRight: () => fineAdjustPosition('x', 0.01),
            fineUp: () => fineAdjustPosition('y', 0.01),
            fineDown: () => fineAdjustPosition('y', -0.01),
            fineForward: () => fineAdjustPosition('z', 0.01),
            fineBackward: () => fineAdjustPosition('z', -0.01),
            reset: resetPosition,
            setPreset: setPresetPosition,
            setPosition: (x, y, z) => {
                currentPosition = { x, y, z };
                updateObjectPosition();
            },
            getPosition: () => currentPosition,
            toggleDebug: () => {
                const centerPoint = document.getElementById('center-point');
                const xAxis = document.getElementById('x-axis');
                const zAxis = document.getElementById('z-axis');
                const boundary = document.getElementById('marker-boundary');
                if (centerPoint) {
                    const visible = centerPoint.getAttribute('visible') === 'true';
                    centerPoint.setAttribute('visible', !visible);
                    if (xAxis) xAxis.setAttribute('visible', !visible);
                    if (zAxis) zAxis.setAttribute('visible', !visible);
                    if (boundary) boundary.setAttribute('visible', !visible);
                }
            },
            optimizeMasking: () => {
                adjustRenderingOrder();
                console.log('Masking optimization applied');
            },
            optimizeForIOS: () => {
                const result = optimizeForIOSSafari();
                console.log('iOS optimization:', result ? 'applied' : 'not applicable');
                return result;
            },
            getDeviceInfo: () => {
                return {
                    userAgent: navigator.userAgent,
                    isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
                    isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                    webGPU: !!navigator.gpu,
                    devicePixelRatio: window.devicePixelRatio
                };
            }
        };
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'ArrowLeft':
                    adjustPosition('left');
                    break;
                case 'ArrowRight':
                    adjustPosition('right');
                    break;
                case 'ArrowUp':
                    adjustPosition('up');
                    break;
                case 'ArrowDown':
                    adjustPosition('down');
                    break;
                case 'r':
                case 'R':
                    resetPosition();
                    break;
            }
        });
    </script>
</body>
</html>