<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Keyholder - iOS Safari Optimized</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.js"></script>
    
    <!-- ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ¼ã‚«ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ -->
    <script>
        AFRAME.registerComponent('markerhandler', {
            init: function () {
                this.marker = this.el;
                this.characterContainer = null;
                this.isMarkerVisible = false;
                this.manualOffset = {x: 0, y: 0, z: 0};
                
                // iOS Safari detection and correction
                this.isIOSSafari = this.detectIOSSafari();
                this.correction = this.calculateIOSCorrection();
                
                console.log('ğŸ¯ Advanced marker handler initialized with iOS Safari correction');
                console.log('iOS Safari detected:', this.isIOSSafari);
                console.log('Correction values:', this.correction);
                
                this.marker.addEventListener('markerFound', () => {
                    console.log('ğŸ¯ Marker found - applying iOS Safari corrections');
                    this.isMarkerVisible = true;
                    
                    if (!this.characterContainer) {
                        this.characterContainer = this.marker.querySelector('#character-container');
                    }
                });
                
                this.marker.addEventListener('markerLost', () => {
                    console.log('ğŸ¯ Marker lost - stopping sync');
                    this.isMarkerVisible = false;
                });
            },
            
            detectIOSSafari: function() {
                const ua = navigator.userAgent;
                const isIOS = /iPad|iPhone|iPod/.test(ua);
                const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS/.test(ua);
                return isIOS && isSafari;
            },
            
            calculateIOSCorrection: function() {
                if (!this.isIOSSafari) {
                    return { x: 0, y: 0, z: 0, scale: 1 };
                }
                
                const viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight
                };
                
                // iOS Safari specific corrections based on Claude's analysis
                const isPortrait = viewport.height > viewport.width;
                const aspectRatio = viewport.width / viewport.height;
                
                // Dynamic correction based on actual viewport
                let correction = {
                    x: 0,
                    y: 0,
                    z: 0,
                    scale: 1
                };
                
                if (isPortrait) {
                    // Portrait mode corrections (393x480 case)
                    const expectedAspect = 4/3; // AR.js expects 4:3
                    const actualAspect = aspectRatio;
                    const aspectCorrection = (expectedAspect - actualAspect) * 0.5;
                    
                    correction.x = aspectCorrection * 0.3; // Right shift compensation
                    correction.y = 0;
                    correction.z = 0;
                    
                    console.log('iOS Portrait correction applied:', correction);
                } else {
                    // Landscape mode corrections
                    correction.x = 0.05;
                    correction.y = 0;
                    correction.z = 0;
                    
                    console.log('iOS Landscape correction applied:', correction);
                }
                
                return correction;
            },
            
            tick: function (time, timeDelta) {
                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®ãŸã‚ã€ãƒ•ãƒ¬ãƒ¼ãƒ é–“éš”ã‚’ãƒã‚§ãƒƒã‚¯
                if (!this.lastTick || timeDelta > 16) { // ç´„60FPSåˆ¶é™
                    this.lastTick = time;
                    
                    // ãƒãƒ¼ã‚«ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹é–“ã®ã¿åŒæœŸ
                    if (this.isMarkerVisible && this.characterContainer) {
                        // iOS Safariè£œæ­£å€¤ã‚’é©ç”¨
                        const finalX = this.manualOffset.x + (this.isIOSSafari ? this.correction.x : 0);
                        const finalY = this.manualOffset.y + (this.isIOSSafari ? this.correction.y : 0);
                        const finalZ = this.manualOffset.z + (this.isIOSSafari ? this.correction.z : 0);
                        
                        this.characterContainer.object3D.position.set(finalX, finalY, finalZ);
                        this.characterContainer.object3D.rotation.set(0, 0, 0);
                        this.characterContainer.object3D.scale.set(
                            this.correction.scale, 
                            this.correction.scale, 
                            this.correction.scale
                        );
                        
                        // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‚‚å¼·åˆ¶æ›´æ–°
                        this.characterContainer.object3D.updateMatrixWorld(true);
                        
                        // iOS Safariç”¨ã®è¿½åŠ è£œæ­£ - Three.js ãƒ¬ãƒ™ãƒ«ã§ã®è¡Œåˆ—ä¿®æ­£
                        if (this.isIOSSafari && this.characterContainer.object3D.parent) {
                            this.applyThreeJSCorrection();
                        }
                    }
                }
            },
            
            applyThreeJSCorrection: function() {
                // Three.js ãƒ¬ãƒ™ãƒ«ã§ã®åº§æ¨™ç³»è£œæ­£
                const container = this.characterContainer.object3D;
                const marker = this.marker.object3D;
                
                // iOS Safariç”¨ã®è¿½åŠ è¡Œåˆ—å¤‰æ›
                if (marker.matrixWorld) {
                    const correctionMatrix = new THREE.Matrix4();
                    correctionMatrix.makeTranslation(this.correction.x, this.correction.y, this.correction.z);
                    
                    // å…ƒã®å¤‰æ›è¡Œåˆ—ã«è£œæ­£ã‚’é©ç”¨
                    const originalMatrix = container.matrix.clone();
                    container.matrix.multiplyMatrices(correctionMatrix, originalMatrix);
                    container.matrixWorldNeedsUpdate = true;
                }
            },
            
            setOffset: function(x, y, z) {
                this.manualOffset.x = x;
                this.manualOffset.y = y;
                this.manualOffset.z = z;
                console.log('Manual offset set:', this.manualOffset);
                console.log('iOS correction:', this.correction);
                console.log('Final position will be:', {
                    x: x + (this.isIOSSafari ? this.correction.x : 0),
                    y: y + (this.isIOSSafari ? this.correction.y : 0),
                    z: z + (this.isIOSSafari ? this.correction.z : 0)
                });
            },
            
            recalculateCorrection: function() {
                // ç”»é¢å›è»¢ã‚„ãƒªã‚µã‚¤ã‚ºæ™‚ã®è£œæ­£å€¤å†è¨ˆç®—
                this.correction = this.calculateIOSCorrection();
                console.log('iOS correction recalculated:', this.correction);
            }
        });
    </script>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; 
            overflow: hidden; 
            background: #000;
        }
        
        #ar-scene { 
            width: 100vw; 
            height: 100vh; 
        }
        
        #status-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            max-width: 400px;
            backdrop-filter: blur(10px);
        }
        
        .status-item {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .status-ok { color: #4ade80; }
        .status-error { color: #f87171; }
        .status-warning { color: #fbbf24; }
        
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }
        
        .marker-link {
            color: #60a5fa;
            text-decoration: none;
            margin-top: 10px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <!-- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º -->
    <div id="status-overlay">
        <h3>ğŸ¯ AR Keyholder</h3>
        <div class="status-item" id="camera-status">ğŸ“· ã‚«ãƒ¡ãƒ©: <span class="status-ok">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–</span></div>
        <div class="status-item" id="ar-status">ğŸ” AR: <span class="status-ok">æº–å‚™å®Œäº†</span></div>
        <div class="status-item" id="marker-status">ğŸ“ ãƒãƒ¼ã‚«ãƒ¼: æ¤œå‡ºå¾…æ©Ÿä¸­</div>
        <div class="status-item" id="visibility-status">ğŸ‘ï¸ è¡¨ç¤º: <span class="status-warning">å¾…æ©Ÿä¸­</span></div>
    </div>
    
    <!-- ä½¿ç”¨æ–¹æ³• -->
    <div id="instructions">
        <strong>ğŸ“– ä½¿ç”¨æ–¹æ³•:</strong><br>
        1. ç‰©ç†çš„ãªã‚­ãƒ¼ãƒ›ãƒ«ãƒ€ãƒ¼ã®æŸ„ã€ã¾ãŸã¯<a href="https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/images/hiro.png" 
              target="_blank" class="marker-link">Hiroãƒãƒ¼ã‚«ãƒ¼</a>ã‚’ç”¨æ„<br>
        2. ãƒãƒ¼ã‚«ãƒ¼ã‚’ã‚«ãƒ¡ãƒ©ã«å‘ã‘ã¦ãã ã•ã„<br>
        3. ã‚­ãƒ¼ãƒ›ãƒ«ãƒ€ãƒ¼ã®ä¸Šã«3Dã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ï¼
    </div>

    <!-- AR.js Scene - è¦–èªæ€§æœ€å„ªå…ˆ -->
    <a-scene
        id="ar-scene"
        vr-mode-ui="enabled: false"
        renderer="logarithmicDepthBuffer: true; colorManagement: true; antialias: true; alpha: true; sortObjects: true; physicallyCorrectLights: true;"
        embedded
arjs="
            trackingMethod: best; 
            sourceType: webcam; 
            debugUIEnabled: false; 
            detectionMode: mono_and_matrix; 
            matrixCodeType: 3x3;
            sourceWidth: 960;
            sourceHeight: 640;
            displayWidth: 960;
            displayHeight: 640;
            maxDetectionRate: 30;
            canvasWidth: 960;
            canvasHeight: 640;
        "
        loading-screen="enabled: false"
        arjs-video-aspect-ratio-fix>
        
        <!-- Hiroãƒãƒ¼ã‚«ãƒ¼ -->
        <a-marker 
            preset="hiro" 
            id="hiro-marker"
            smooth="true"
            smoothCount="5"
            smoothTolerance="0.01"
            smoothThreshold="2"
            markerhandler>
            
            <!-- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ¢ãƒ‡ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ - ç‰©ç†ã‚­ãƒ¼ãƒ›ãƒ«ãƒ€ãƒ¼æŸ„ã®ä¸Šã«è¡¨ç¤º -->
            <a-entity id="character-container" position="0 0 0" rotation="0 0 0" scale="1 1 1">
                
                <!-- åŸºæº–ç‚¹ï¼ˆç·‘ã®çƒï¼‰ - ãƒãƒ¼ã‚«ãƒ¼ä¸­å¿ƒç¢ºèªç”¨ -->
                <a-sphere
                    id="center-reference"
                    position="0 0 0"
                    radius="0.03"
                    color="#00ff00"
                    material="emissive: #00ff00; emissiveIntensity: 3.0; transparent: true; opacity: 0.9;"
                    visible="true">
                </a-sphere>
                
                <!-- ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ†ã‚¹ãƒˆã‚¹ãƒ•ã‚£ã‚¢ -->
                <a-sphere
                    id="test-sphere"
                    position="0 0.5 0"
                    radius="0.1"
                    color="#ff0000"
                    material="color: #ff0000; emissive: #ff0000; emissiveIntensity: 1.0;"
                    animation="property: scale; to: 1.2 1.2 1.2; dir: alternate; loop: true; dur: 1000"
                    visible="false">
                </a-sphere>
                
                <!-- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ¢ãƒ‡ãƒ«ãŒã“ã“ã«å‹•çš„ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                
            </a-entity>
        </a-marker>
        
        <!-- å¼·åŠ›ãªãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚° -->
        <a-light type="ambient" color="#ffffff" intensity="1.0"></a-light>
        <a-light type="directional" position="0 1 0" color="#ffffff" intensity="1.0"></a-light>
        <a-light type="point" position="0 2 1" color="#ffffff" intensity="0.8"></a-light>
        
        <!-- ã‚«ãƒ¡ãƒ© -->
        <a-entity camera></a-entity>
    </a-scene>

    <script>
        // DOMè¦ç´ 
        const markerStatus = document.getElementById('marker-status');
        const visibilityStatus = document.getElementById('visibility-status');
        
        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°é–¢æ•°
        function updateStatus(element, message, type = 'ok') {
            const statusClasses = { ok: 'status-ok', error: 'status-error', warning: 'status-warning' };
            element.innerHTML = element.innerHTML.split(':')[0] + ': ' + 
                `<span class="${statusClasses[type]}">${message}</span>`;
        }
        
        // ARã‚·ãƒ¼ãƒ³åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸ¯ AR Keyholder - iOS Safari Optimized Version');
            
            const arScene = document.querySelector('a-scene');
            const marker = document.querySelector('#hiro-marker');
            const characterContainer = document.querySelector('#character-container');
            const testSphere = document.querySelector('#test-sphere');
            
            // iOS Safariç‰¹åŒ–åˆæœŸåŒ–
            if (marker && marker.components.markerhandler) {
                const handler = marker.components.markerhandler;
                if (handler.isIOSSafari) {
                    console.log('ğŸ“± iOS Safari detected - applying optimizations');
                    
                    // iOS Safariç”¨ã®ã‚«ãƒ¡ãƒ©è¨­å®šã®æœ€é©åŒ–
                    arScene.setAttribute('arjs', arScene.getAttribute('arjs') + 
                        '; cameraParametersUrl: data/camera_para-iPhone.dat;');
                }
            }
            
            // ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡ºã‚¤ãƒ™ãƒ³ãƒˆ
            marker.addEventListener('markerFound', () => {
                console.log('ğŸ¯ Hiro marker detected - Character display!');
                updateStatus(markerStatus, 'æ¤œå‡ºä¸­ - ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¡¨ç¤º!', 'ok');
                updateStatus(visibilityStatus, 'ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¡¨ç¤ºä¸­!', 'ok');
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚³ãƒ³ãƒ†ãƒŠã‚’å¯è¦–åŒ–
                characterContainer.setAttribute('visible', true);
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ¢ãƒ‡ãƒ«ã«å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                const characterModels = characterContainer.querySelectorAll('a-gltf-model, a-sphere#test-sphere');
                characterModels.forEach(model => {
                    model.setAttribute('animation__appear', {
                        property: 'scale',
                        from: '0 0 0',
                        to: '1 1 1',
                        dur: 800,
                        easing: 'easeOutQuad'
                    });
                });
            });
            
            marker.addEventListener('markerLost', () => {
                console.log('Hiro marker lost');
                updateStatus(markerStatus, 'æœªæ¤œå‡º - ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¢ã—ã¦ã„ã¾ã™', 'warning');
                updateStatus(visibilityStatus, 'å¾…æ©Ÿä¸­', 'warning');
            });
            
            // AR.jsåˆæœŸåŒ–å®Œäº†ã‚¤ãƒ™ãƒ³ãƒˆ
            arScene.addEventListener('arjs-video-loaded', () => {
                console.log('ğŸš€ AR.js video loaded - iOS Safari optimized!');
                updateStatus(markerStatus, 'æ¤œå‡ºå¾…æ©Ÿä¸­', 'warning');
                
                // iOS Safariç”¨ã®è¿½åŠ æœ€é©åŒ–
                const marker = document.querySelector('#hiro-marker');
                if (marker && marker.components.markerhandler && marker.components.markerhandler.isIOSSafari) {
                    // åˆæœŸè£œæ­£ã‚’é©ç”¨
                    setTimeout(() => {
                        ARKeyholder.quickFix();
                        console.log('ğŸ“± iOS Safari initial correction applied');
                    }, 1000);
                }
            });
            
            // ç”»é¢å›è»¢ã‚¤ãƒ™ãƒ³ãƒˆã§è£œæ­£å€¤ã‚’å†è¨ˆç®—
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    const marker = document.querySelector('#hiro-marker');
                    if (marker && marker.components.markerhandler) {
                        marker.components.markerhandler.recalculateCorrection();
                        console.log('ğŸ”„ Screen orientation changed - iOS correction recalculated');
                    }
                }, 500);
            });
            
            // ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆã§è£œæ­£å€¤ã‚’å†è¨ˆç®—
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    const marker = document.querySelector('#hiro-marker');
                    if (marker && marker.components.markerhandler) {
                        marker.components.markerhandler.recalculateCorrection();
                        console.log('ğŸ“œ Window resized - iOS correction recalculated');
                    }
                }, 300);
            });
        });
        
        // ãƒ‡ãƒãƒƒã‚°ç”¨ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°
        window.ARKeyholder = {
            version: '3.6.0-ios-safari-fix',
            forceCenter: () => {
                const container = document.querySelector('#character-container');
                container.object3D.position.set(0, 0, 0);
                container.object3D.rotation.set(0, 0, 0);
                container.object3D.scale.set(1, 1, 1);
                container.object3D.updateMatrix();
                console.log('Force centered at (0,0,0)');
                console.log('Actual position:', container.object3D.position);
            },
            showReferences: () => {
                const ref = document.querySelector('#center-reference');
                const test = document.querySelector('#test-sphere');
                ref.setAttribute('visible', true);
                test.setAttribute('visible', true);
                console.log('Reference spheres visible - Green=center(0,0,0), Red=height test(0,0.5,0)');
            },
            hideReferences: () => {
                const ref = document.querySelector('#center-reference');
                const test = document.querySelector('#test-sphere');
                ref.setAttribute('visible', false);
                test.setAttribute('visible', false);
                console.log('Reference spheres hidden');
            },
            adjustCharacter: (x, y, z) => {
                // ãƒãƒ¼ã‚«ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨­å®š
                const marker = document.querySelector('#hiro-marker');
                if (marker && marker.components.markerhandler) {
                    marker.components.markerhandler.setOffset(x, y, z);
                    console.log(`Character position offset set to: ${x}, ${y}, ${z}`);
                } else {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç›´æ¥èª¿æ•´
                    const wrapper = document.querySelector('#model-wrapper');
                    if (wrapper) {
                        wrapper.object3D.position.set(x, y, z);
                        wrapper.object3D.updateMatrixWorld(true);
                        console.log(`Character wrapper moved to: ${x}, ${y}, ${z}`);
                    } else {
                        const container = document.querySelector('#character-container');
                        if (container) {
                            container.object3D.position.set(x, y, z);
                            container.object3D.updateMatrixWorld(true);
                            console.log(`Character container moved to: ${x}, ${y}, ${z}`);
                        }
                    }
                }
            },
            getMarkerMatrix: () => {
                const marker = document.querySelector('#hiro-marker');
                console.log('Marker matrix:', marker.object3D.matrix);
                console.log('Marker position:', marker.object3D.position);
                return marker.object3D.matrix;
            },
            debugInfo: () => {
                const marker = document.querySelector('#hiro-marker');
                const container = document.querySelector('#character-container');
                const wrapper = document.querySelector('#model-wrapper');
                console.log('=== DEBUG INFO ===');
                console.log('Marker position:', marker.object3D.position);
                console.log('Container position:', container.object3D.position);
                console.log('Container world position:', container.object3D.getWorldPosition(new THREE.Vector3()));
                if (wrapper) {
                    console.log('Model wrapper position:', wrapper.object3D.position);
                    console.log('Wrapper world position:', wrapper.object3D.getWorldPosition(new THREE.Vector3()));
                }
                return {
                    marker: marker.object3D.position,
                    container: container.object3D.position,
                    containerWorld: container.object3D.getWorldPosition(new THREE.Vector3()),
                    wrapper: wrapper ? wrapper.object3D.position : null
                };
            },
            testOffsets: () => {
                console.log('Testing different offset values...');
                const offsets = [
                    {x: 0, y: 0, z: 0, name: 'Center'},
                    {x: -0.1, y: 0, z: 0, name: 'Left adjust'},
                    {x: 0.1, y: 0, z: 0, name: 'Right adjust'},
                    {x: 0, y: 0, z: -0.1, name: 'Forward adjust'},
                    {x: 0, y: 0, z: 0.1, name: 'Backward adjust'}
                ];
                
                let i = 0;
                const testNext = () => {
                    if (i < offsets.length) {
                        const offset = offsets[i];
                        ARKeyholder.adjustCharacter(offset.x, offset.y, offset.z);
                        console.log(`Testing: ${offset.name} (${offset.x}, ${offset.y}, ${offset.z})`);
                        i++;
                        setTimeout(testNext, 2000);
                    } else {
                        console.log('Test complete. Use ARKeyholder.adjustCharacter(x,y,z) to set desired position');
                    }
                };
                testNext();
            },
            checkMarkerStatus: () => {
                const marker = document.querySelector('#hiro-marker');
                const arScene = document.querySelector('a-scene');
                console.log('=== MARKER STATUS ===');
                console.log('Marker element:', marker);
                console.log('AR scene:', arScene);
                console.log('Marker visible:', marker ? marker.object3D.visible : 'No marker');
                console.log('AR.js initialized:', window.THREEx && window.THREEx.ArToolkitContext ? 'Yes' : 'No');
                return {
                    hasMarker: !!marker,
                    hasArScene: !!arScene,
                    markerVisible: marker ? marker.object3D.visible : false
                };
            },
            resetAR: () => {
                console.log('Attempting AR reset...');
                location.reload();
            },
            quickFix: () => {
                console.log('Applying iOS Safari specific fixes...');
                const marker = document.querySelector('#hiro-marker');
                if (marker && marker.components.markerhandler) {
                    const handler = marker.components.markerhandler;
                    if (handler.isIOSSafari) {
                        // iOS Safariç”¨ã®è‡ªå‹•è£œæ­£
                        const correction = handler.correction;
                        ARKeyholder.adjustCharacter(correction.x, correction.y, correction.z);
                        console.log('Applied iOS Safari correction:', correction);
                    } else {
                        // ä¸€èˆ¬çš„ãªä¿®æ­£å€¤
                        ARKeyholder.adjustCharacter(0.1, 0, 0);
                        console.log('Applied standard right offset (+0.1)');
                    }
                } else {
                    ARKeyholder.adjustCharacter(0.1, 0, 0);
                }
            },
            
            iosDebugInfo: () => {
                const marker = document.querySelector('#hiro-marker');
                if (marker && marker.components.markerhandler) {
                    const handler = marker.components.markerhandler;
                    console.log('=== iOS SAFARI DEBUG INFO ===');
                    console.log('iOS Safari detected:', handler.isIOSSafari);
                    console.log('Viewport:', { width: window.innerWidth, height: window.innerHeight });
                    console.log('User Agent:', navigator.userAgent);
                    console.log('iOS correction:', handler.correction);
                    console.log('Manual offset:', handler.manualOffset);
                    
                    const aspectRatio = window.innerWidth / window.innerHeight;
                    console.log('Aspect ratio:', aspectRatio);
                    console.log('Is portrait:', window.innerHeight > window.innerWidth);
                    
                    return {
                        isIOSSafari: handler.isIOSSafari,
                        viewport: { width: window.innerWidth, height: window.innerHeight },
                        aspectRatio: aspectRatio,
                        isPortrait: window.innerHeight > window.innerWidth,
                        correction: handler.correction,
                        manualOffset: handler.manualOffset
                    };
                }
                return null;
            },
            
            recalibrateIOS: () => {
                const marker = document.querySelector('#hiro-marker');
                if (marker && marker.components.markerhandler) {
                    marker.components.markerhandler.recalculateCorrection();
                    console.log('iOS Safari correction recalibrated');
                }
            },
            centerTest: () => {
                console.log('Testing center position with visible markers...');
                ARKeyholder.showReferences();
                ARKeyholder.adjustCharacter(0, 0, 0);
                console.log('Green sphere = marker center, Red sphere = height reference');
                console.log('If character is not on green sphere, use ARKeyholder.adjustCharacter(x,y,z)');
            },
            loadProject: (projectId) => {
                const url = new URL(window.location);
                url.searchParams.set('project', projectId);
                window.location.href = url.toString();
            },
            
            // iOS Safariç”¨ã®è¿½åŠ èª¿æ•´ãƒ˜ãƒ«ãƒ‘ãƒ¼
            fineTuneCenter: (offsetX = -0.1) => {
                console.log(`Fine-tuning center position with offset: ${offsetX}`);
                ARKeyholder.adjustCharacter(offsetX, 0, 0);
                ARKeyholder.showReferences();
                console.log('Use ARKeyholder.fineTuneCenter(-0.15) for more left adjustment');
                console.log('Use ARKeyholder.fineTuneCenter(-0.05) for less left adjustment');
            },
            
            autoCenter: () => {
                console.log('Auto-centering for current device...');
                const marker = document.querySelector('#hiro-marker');
                if (marker && marker.components.markerhandler) {
                    const handler = marker.components.markerhandler;
                    if (handler.isIOSSafari) {
                        // iOS Safariç”¨ã®è‡ªå‹•ä¸­å¤®å¯„ã›
                        ARKeyholder.quickFix();
                        ARKeyholder.showReferences();
                        console.log('ğŸ“± iOS Safari auto-centering applied');
                    } else {
                        // ä»–ã®ãƒ–ãƒ©ã‚¦ã‚¶ç”¨
                        ARKeyholder.forceCenter();
                        ARKeyholder.showReferences();
                        console.log('ğŸ’» Standard auto-centering applied');
                    }
                } else {
                    ARKeyholder.forceCenter();
                }
            }
        };
        
        // Supabaseè¨­å®š
        const SUPABASE_URL = 'https://flqbgdqtphokkekminvo.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZscWJnZHF0cGhva2tla21pbnZvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk1NjgyMjIsImV4cCI6MjA2NTE0NDIyMn0.rEXiy6TbMVflwpkDv9z1pMV6lsrmW7ukM81qGj4pfp0';
        const SUPABASE_HEADERS = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
            'apikey': SUPABASE_ANON_KEY
        };

        // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ï¼ˆSupabaseå¯¾å¿œï¼‰
        async function loadProjectData() {
            const urlParams = new URLSearchParams(window.location.search);
            const projectId = urlParams.get('project');
            
            if (projectId) {
                try {
                    console.log('Loading project from Supabase:', projectId);
                    
                    // Supabaseã‹ã‚‰ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/projects?id=eq.${projectId}&select=*`, {
                        method: 'GET',
                        headers: SUPABASE_HEADERS
                    });
                    
                    let projectData;
                    
                    if (response.ok) {
                        const supabaseProjects = await response.json();
                        console.log('Raw Supabase project data:', supabaseProjects);
                        
                        if (supabaseProjects && supabaseProjects.length > 0) {
                            const supabaseProject = supabaseProjects[0];
                            
                            // Supabaseãƒ‡ãƒ¼ã‚¿ã‚’æ—¢å­˜å½¢å¼ã«å¤‰æ›
                            projectData = {
                                id: supabaseProject.id,
                                name: supabaseProject.title,
                                metadata: { 
                                    description: supabaseProject.description || '' 
                                },
                                character: {
                                    modelUrl: supabaseProject.model_url || 'keyholder-default',
                                    scale: 1,
                                    position: [0, 0.5, 0]
                                },
                                marker: { 
                                    imageUrl: supabaseProject.image_url || '' 
                                },
                                created_at: supabaseProject.created_at
                            };
                            
                            console.log('Converted project data:', projectData);
                        }
                    } else {
                        console.warn('Supabase fetch failed, trying localStorage');
                    }
                    
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å–å¾—
                    if (!projectData) {
                        const projects = JSON.parse(localStorage.getItem('ar-projects') || '[]');
                        projectData = projects.find(p => p.id === projectId);
                        console.log('Project loaded from localStorage:', projectData);
                    }
                    
                    if (projectData) {
                        await applyProjectSettings(projectData);
                        updateStatus(document.getElementById('ar-status'), `ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: ${projectData.name}`, 'ok');
                    } else {
                        console.warn('Project not found:', projectId);
                        updateStatus(document.getElementById('ar-status'), 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'error');
                    }
                } catch (error) {
                    console.error('Project loading error:', error);
                    updateStatus(document.getElementById('ar-status'), 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼', 'error');
                    
                    // æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                    try {
                        const projects = JSON.parse(localStorage.getItem('ar-projects') || '[]');
                        const projectData = projects.find(p => p.id === projectId);
                        if (projectData) {
                            await applyProjectSettings(projectData);
                            updateStatus(document.getElementById('ar-status'), `ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: ${projectData.name} (ãƒ­ãƒ¼ã‚«ãƒ«)`, 'warning');
                        }
                    } catch (fallbackError) {
                        console.error('Fallback error:', fallbackError);
                    }
                }
            } else {
                console.log('No project ID specified, using default settings');
                updateStatus(document.getElementById('ar-status'), 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤º', 'ok');
            }
        }
        
        // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®šã®é©ç”¨
        async function applyProjectSettings(projectData) {
            try {
                console.log('Applying project settings:', projectData);
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ¢ãƒ‡ãƒ«ã®è¨­å®š
                if (projectData.character && projectData.character.modelUrl) {
                    const modelUrl = projectData.character.modelUrl;
                    console.log('Loading character model:', modelUrl);
                    
                    // keyholder-defaultä»¥å¤–ã®ãƒ¢ãƒ‡ãƒ«ã®ã¿è¡¨ç¤ºï¼ˆç‰©ç†ã‚­ãƒ¼ãƒ›ãƒ«ãƒ€ãƒ¼ã®ä¸Šã«ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’è¡¨ç¤ºï¼‰
                    if (modelUrl && modelUrl !== 'keyholder-default' && modelUrl !== '') {
                        const characterContainer = document.querySelector('#character-container');
                        
                        // Base64ãƒ‡ãƒ¼ã‚¿ã‹URLã‹ã‚’åˆ¤å®š
                        let modelSrc = modelUrl;
                        if (modelUrl.startsWith('data:application/octet-stream')) {
                            // Base64ãƒ‡ãƒ¼ã‚¿ã®å ´åˆã¯ãã®ã¾ã¾ä½¿ç”¨
                            console.log('Loading Base64 GLB model');
                            modelSrc = modelUrl;
                        } else if (modelUrl.startsWith('http')) {
                            // å¤–éƒ¨URLã®å ´åˆ
                            console.log('Loading external GLB model from URL');
                            modelSrc = modelUrl;
                        }
                        
                        // GLTFãƒ¢ãƒ‡ãƒ«ã‚’è¿½åŠ 
                        const gltfEntity = document.createElement('a-gltf-model');
                        gltfEntity.setAttribute('src', modelSrc);
                        // ãƒ€ãƒŸãƒ¼è¦ªã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ä½œæˆã—ã¦ãƒ¢ãƒ‡ãƒ«ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è£œæ­£
                        const modelWrapper = document.createElement('a-entity');
                        modelWrapper.setAttribute('id', 'model-wrapper');
                        modelWrapper.setAttribute('position', '0 0 0');
                        
                        gltfEntity.setAttribute('position', projectData.character.position ? 
                            `${projectData.character.position[0]} ${projectData.character.position[1]} ${projectData.character.position[2]}` : 
                            '0 0.3 0');  // ç‰©ç†ã‚­ãƒ¼ãƒ›ãƒ«ãƒ€ãƒ¼ã®ä¸Šã«è¡¨ç¤º
                        gltfEntity.setAttribute('scale', `${projectData.character.scale || 1} ${projectData.character.scale || 1} ${projectData.character.scale || 1}`);
                        gltfEntity.setAttribute('rotation', '0 0 0');
                        
                        // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ã‚¤ãƒ™ãƒ³ãƒˆ
                        gltfEntity.addEventListener('model-loaded', () => {
                            console.log('âœ… Character model loaded successfully');
                            updateStatus(document.getElementById('ar-status'), `ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿å®Œäº†: ${projectData.name}`, 'ok');
                        });
                        
                        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
                        gltfEntity.addEventListener('model-error', (event) => {
                            console.error('âŒ Character model loading failed:', event.detail);
                            updateStatus(document.getElementById('ar-status'), 'ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼', 'error');
                            gltfEntity.remove();
                        });
                        
                        modelWrapper.appendChild(gltfEntity);
                        characterContainer.appendChild(modelWrapper);
                        console.log('Character model entity created:', modelSrc.substring(0, 100) + '...');
                    } else {
                        console.log('No character model specified or default keyholder selected');
                        updateStatus(document.getElementById('ar-status'), 'ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãªã— - ç‰©ç†ã‚­ãƒ¼ãƒ›ãƒ«ãƒ€ãƒ¼ã®ã¿', 'ok');
                    }
                } else {
                    console.log('No character data found');
                    updateStatus(document.getElementById('ar-status'), 'ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãªã—', 'ok');
                }
                
                // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ã‚’è¡¨ç¤º
                updateStatus(document.getElementById('ar-status'), `ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: ${projectData.name}`, 'ok');
                
            } catch (error) {
                console.error('Error applying project settings:', error);
                updateStatus(document.getElementById('ar-status'), 'è¨­å®šé©ç”¨ã‚¨ãƒ©ãƒ¼', 'error');
            }
        }
        
        // ARè¡¨ç¤ºå›æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
        function incrementViewCount() {
            const currentViews = parseInt(localStorage.getItem('ar-total-views') || '0');
            localStorage.setItem('ar-total-views', (currentViews + 1).toString());
            console.log('AR view count incremented:', currentViews + 1);
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã®åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            loadProjectData();
            incrementViewCount();
            
            // iOS Safariæ¤œå‡ºãƒ­ã‚°
            const ua = navigator.userAgent;
            const isIOS = /iPad|iPhone|iPod/.test(ua);
            const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS/.test(ua);
            
            if (isIOS && isSafari) {
                console.log('ğŸ“± iOS Safari detected - enhanced positioning enabled');
                console.log('Device info:', {
                    userAgent: ua,
                    viewport: { width: window.innerWidth, height: window.innerHeight },
                    devicePixelRatio: window.devicePixelRatio
                });
                
                // iOS Safariç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´
                document.body.style.webkitUserSelect = 'none';
                document.body.style.webkitTouchCallout = 'none';
            }
        });
    </script>
</body>
</html>